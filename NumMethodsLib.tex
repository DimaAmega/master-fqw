\begin{chapter}{Программный комплекс}

	Программный комплекс, описываемый в этой главе, позволяет находить вращательные движения и
	определять их устойчивость в системах связанных фазовых элементов, которые описываются системой обыкновенных
	дифференциальных уравнений.

\section{Описание алгоритмов нахождения вращательных движений и определения их устойчивости}
	Для того, чтобы воспроизвести интересующее вращательное движение, необходимо иметь
	начальные условия и период вращательного движения. Для нахождения этих величин предлагается использовать
	алгоритмы для нахождения нулей некоторой многомерной функции, подробное устройство которой описано в \cite{Khorkin}.
	Для этого можно использовать метод Ньютона.
	Анализ устойчивости может быть произведен в рамках теории Флоке. Для этого необходимо найти
	собственные числа матрицы монодромии некоторой линейной системы с периодическими коэффициентами.
	Данная линейная система описывает динамику вариаций относительно найденного вращательного режима. Если все собственные числа матрицы монодромии находятся в пределах
	единичной окружности комплексной плоскости, рассматриваемый вращательный режим является линейно устойчивым.
	Стоит отметить тот факт, что для нахождения матрицы монодромии происходит интегрирование сразу двух систем одновременно:
	полной, в которой реализуется вращательное движение, а также линейной, из которой составляется матрица монодромии.  
\section{Описание структуры программного комплекса}
Программный комплекс написан на языке программирования python с использованием таких
библиотек как scipy \cite{scipy}, numpy \cite{numpy} и numba \cite{numba}.
Были реализованы три главных модуля: модуль интегрирования, модуль нахождения нулей многомерной функции, модуль, выполняющий расчет
матрицы монодромии.
Особый интерес представляет библиотека numba, которая реализует процедуру 
компиляции python кода в машинный код во время исполнения (jit compilation).
В частности, компиляция во время исполнения выполняется для функций, описывающих динамику системы.
Благодаря этому нахождение вращательных движений и определение их устойчивости реализованно эффективно.
В программном комплексе присутствует набор тестов \cite{testing}, проверяющих корректность работы главных алгоритмов.

\section{Модуль численного интегрирования}
Данный модуль позволяет произвести численное интегрирование систем обыкновенных
дифференциальных уравнений, тем самым решить задачу Коши:

$$
\dot{X} = F(X, t), \ X \in \mathbb{R}^n, \ t \in \mathbb{R}, \ X(t_0) = X_0, \ t_0 \in \mathbb{R}, \ X_0 \in \mathbb{R}^n
$$

Интегрирование производится наиболее часто используемым методом Рунге--Кутта 4--го порядка.

Входные параметры: $$F(X, t, ...args), \ t_0, \ X_0,  \ t_{end}, \ args = (), \ h=0.001,$$
где $F(X, t, ...args)$ -- правая часть системы. \\
$t_0$ -- начальный момент времени. \\
$X_0$ -- начальные условия в момент времени $t_0$. \\
$args$ -- вектор параметров, используемый в $F(X, t, ...args)$. Значение по умолчанию пустой вектор.
$t_{end}$ -- конечный момент времени. \\
$h$ -- шаг численного метода. Значение по умолчанию $h = 0.001$. \\
Выходные параметры: $$ q \in \mathbb{R}^n,$$
где $q$ -- вектор состояния в момент времени $t_{end}$.

В данном модуле применяется такая техника, как <<компиляция во время исполнения>>
для функций $F(X, t, ...args)$, описывающих правую часть системы. Компиляция сохраняется в кэш, тем
самым предотвращая повторные компиляции $F(X, t, ...args)$ для разных вызовов.
Техника компиляции во времени исполнения отнимает некоторое время на старте программы, но в конечном итоге ускоряет вычисления.

\section{Модуль нахождения нулей многомерной функции}
Данный модуль позволяет найти нули некоторой многомерной функции $F: \mathbb{R}^n \rightarrow \mathbb{R}^n$ соответствующим методом Ньютона.
В своей основе использует предыдущий модуль.

Входные параметры: $$
F(X, ...args),  \ X_0, \ \epsilon=0.001, \ K\_MAX=100,
$$
$$
\ yacoby\_matrix=False, \ args = (),$$
где $F(X, ...args)$ -- многомерная функция. \\
$X_0$ -- начальные точка. \\
$\epsilon$ -- точность метода, участвует в критерии остановки вида $\left\Vert d \right\Vert^2 \le \epsilon$, где $d$ -- вектор смещения для новой точки: $X_{k+1} = X_k + d$. Значение по умолчанию $\epsilon = 0.001$. \\
$K\_MAX$ -- максимальное количество итераций метода. Значение по умолчанию $K\_MAX = 100$. \\
$yacoby\_matrix$ -- матрица Якоби для $F(X, ...args)$. Значение по умолчанию $yacoby\_matrix=False$ что означает, не задана пользователем. \\
$args$ -- вектор параметров, используемый в $F(X, ...args)$. Значение по умолчанию пустой вектор. \\
Выходные параметры: $$ q \in \mathbb{R}^n,$$
где $q$ вектор, такой, что $F(q, ...args) \approx 0$.

В данном модуле также применяется техника, компиляции во время исполнения 
для функций $F(X, ...args)$. Компиляция также сохраняется в кэш, тем
самым предотвращая повторные компиляции $F(X, ...args)$ для разных вызовов.


\section{Модуль нахождения вращательных движений}
Данный модуль позволяет найти произвольные вращательные движения.
В своей основе использует предыдущие модули.

Входные параметры: $$F(X, t, ...args), \ args, \ IC_0, T_0 \ phase\_period = 2\pi, h=0.001\ \epsilon=0.001,$$
где $F(X, t, ...args)$ -- правая часть системы. \\
$args$ -- вектор параметров, используемый в $F(X, t, ...args)$. Значение по умолчанию пустой вектор.
$IC_0$ -- начальные значения для реализации искомого вращательного движения, необходимы для метода Ньютона. \\
$T_0$ -- начальный период искомого вращательного движения, необходим для метода Ньютона. \\
$phase\_period$ -- период  вращательных движений по фазе. Значение по умолчанию $phase\_period = 2\pi$. \\
$h$ -- шаг численного метода. Значение по умолчанию $h = 0.001$. \\
$\epsilon$ -- точность метода, необходим для метода Ньютона. Значение по умолчанию $\epsilon = 0.001$.

Выходные параметры: $$T,  \ IC,$$
где $\text{Т}$ -- период искомого вращательного движения. \\
$IC_0$ -- начальные значения для реализации искомого вращательного движения. \\


\section{Модуль определения устойчивости вращательных движений.}
Данный модуль позволяет определить устойчивость найденных вращательных движений.
В своей основе использует предыдущие модули.

Входные параметры: $$F(X, t, ...args_{orig})_{orig}, \ F(X, t, ...args_{linear})_{linear}, \ args_{orig}, \ args_{linear}, \ IC, \ T , h=0.001,$$
где $F(X, t, ...args_{orig})_{orig}$ -- правая часть исходной системы. \\
где $F(X, t, ...args_{linear})_{linear}$ -- правая часть линеаризованной  системы. \\
$args_{orig}$ -- вектор параметров, используемый в $F(X, t, ...args_{orig})_{orig}$. Значение по умолчанию пустой вектор. \\ 
$args_{linear}$ -- вектор параметров, используемый в $F(X, t, ...args_{linear})_{linear}$. Значение по умолчанию пустой вектор. \\
$IC$ -- начальные значения для реализации искомого вращательного движения.\\
$T$ -- начальный период искомого вращательного движения.\\
$h$ -- шаг численного метода. Значение по умолчанию $h = 0.001$. \\

Выходные параметры: $$M$$
где $\text{M}$ -- матрица монодромии.

\section{Ссылки на ресурсы}
Исходный код: https://github.com/unn--dynamic-systems/rotary\_states/

Проект на pypi: https://pypi.org/project/rotary\_states/

Тестирование: https://github.com/unn--dynamic--systems/rotary\_states/actions/

\end{chapter}